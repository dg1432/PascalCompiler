# Project 2 - Syntax Analyzer
November 13, 2014

## Table of Contents
[**Introduction**](#introduction)

[**Methodology**](#methodology)
* [Original Grammar](#original-grammar)
* [Modified Grammar - Remove Left Recursion](#modified-grammar---remove-left-recursion)
* [Modified Grammar - Perform Left Factoring](#modified-grammar---perform-left-factoring)
* [First Sets](#first-sets)
* [Follow Sets](#follow-sets)
* [Parse Table](#parse-table)

[**Implementation**](#implementation)

[**Discussion and Conclusions**](#discussion-and-conclusions)

[**References**](#references)

[**Appendix**](#appendix---sample-inputs-and-outputs)

## Introduction
The compilation process is made up of six main phases: lexical analysis, syntax analysis, semantic analysis, intermediate code generation, code optimization, and target code generation. The role of a syntax analyzer is to "obtain a string of tokens from the lexical analyzer...and [verify] that the string can be generated by the grammar for the source language." (Aho 160) In this project, the syntax analyzer, or parser, employs a recursive descent routine based on an LL(1) grammar and processes the tokens given by the lexical analyzer. It also implements an error recovery system by using synchronizing tokens.

## Methodology
The parser for this project is built using an LL(1) grammar derived from the specified subset of the Pascal programming language. The parser takes a list of tokens, including the lexeme, token type, and attribute, as input. Then, through a recursive descent routine, it parses the tokens against the LL(1) grammar. If there is a mismatch between the expected token(s) and the actual token, the conflict is reported. The steps of producing an LL(1) grammar with first and follow sets as well as a parse table are described in the subsequent set of subsections. There is an ambiguity in this language (the dangling else ambiguity), but we can easily resolve it for now by selecting one production where it occurs in the parse table.

#### Original Grammar
The original Pascal grammar, according to Appendix 3 of *Compilers: Principles, Techniques, and Tools*, with the modifications specified by the Project 2 description is as follows:

*program*

> &#8594; **program id** ( *identifier_list* ) **;** *declarations subprogram_declarations compound_statement* **.**

*identifier_list*

> &#8594; **id** | *identifier_list* **, id**

*declarations*

> &#8594; *declarations* **var id :** *type* **;** | **&#949;**

*type*

> &#8594; *standard_type* | **array [ num .. num ] of** *standard_type*

*standard_type*

> &#8594; **integer** | **real**

*subprogram_declarations*

> &#8594; *subprogram_declarations subprogram_declaration* **;** | **&#949;**

*subprogram_declaration*

> &#8594; *subprogram_head declarations compound_statement* |  
*subprogram_head declarations subprogram_declarations compound_statement*

*subprogram_head*

> &#8594; **procedure id** *arguments* **;**

*arguments*

> &#8594; **(** *parameter_list* **)** | **&#949;**

*parameter_list*

> &#8594; **id :** *type* | *parameter_list* **; id :** *type*

*compound_statement*

> &#8594; **begin** *optional_statements* **end**

*optional_statements*

> &#8594; *statement_list* | **&#949;**

*statement_list*

> &#8594; *statement* | *statement_list* **;** *statement*

*statement*

> &#8594; *variable* **assignop** *expression* | *procedure_statement* | *compound_statement* |  
**if** *expression* **then** *statement* **else** *statement* | **while** *expression* **do** *statement* |  
**if** *expression* **then** *statement*

*variable*

> &#8594; **id** | **id [** *expression* **]**

*procedure_statement*

> &#8594; **call id** | **call id (** *expression_list* **)**

*expression_list*

> &#8594; *expression* | *expression_list* **,** *expression*

*expression*

> &#8594; *simple_expression* | *simple_expression* **relop** *simple_expression*

*simple_expression*

> &#8594; *term* | *sign term* | *simple_expression* **addop** *term*

*term*

> &#8594; *factor* | *term* **mulop** *factor*

*factor*

> &#8594; **id** | **num** | **(** *expression* **)** | **not** *factor* | **id [** *expression* **]**

*sign*

> &#8594; **+** | **–**

#### Modified Grammar - Remove Left Recursion
The above grammar after removing epsilon productions as well as left recursion is as follows:

*program*

> &#8594; **program id (** *identifier_list* **) ;** *declarations subprogram_declarations compound_statement* **.** |  
**program id (** *identifier_list* **) ;** *compound_statement* **.** |  
**program id (** *identifier_list* **) ;** *declarations compound_statement* **.** |  
**program id (** *identifier_list* **) ;** *subprogram_declarations compound_statement* **.**

*identifier_list*

> &#8594; **id** *identifier_list'*

*identifier_list'*

> &#8594; **, id** *identifier_list'* | **&#949;**

*declarations*

> &#8594; **var id :** *type* **;** *declarations'*

*declarations'*

> &#8594; **var id :** *type* **;** *declarations'* | **&#949;**

*type*

> &#8594; *standard_type* | **array [ num .. num ] of** *standard_type*

*standard_type*

> &#8594; **integer** | **real**

*subprogram_declarations*

> &#8594; *subprogram_declaration* **;** **subprogram_declarations'**

*subprogram_declarations'*

> &#8594; *subprogram_declaration* **;** *subprogram_declarations'* | **&#949;**

*subprogram_declaration*

> &#8594; *subprogram_head declarations compound_statement* |  
*subprogram_head declarations subprogram_declarations compound_statement* |  
*subprogram_head compound_statement* |  
*subprogram_head subprogram_declarations compound_statement*

*subprogram_head*

> &#8594; **procedure id** *arguments* **;** | **procedure id ;**

*arguments*

> &#8594; **(** *parameter_list* **)**

*parameter_list*

> &#8594; **id :** *type parameter_list'*

*parameter_list'*

> &#8594; **; id :** *type* *parameter_list'* | **&#949;**

*compound_statement*

> &#8594; **begin** *optional_statements* **end** | **begin end**

*optional_statements*

> &#8594; *statement_list*

*statement_list*

> &#8594; *statement statement_list'*

*statement_list'*

> &#8594; **;** *statement statement_list'* | **&#949;**

*statement*

> &#8594; *variable* **assignop** *expression* | *procedure_statement* | *compound_statement* |  
**if** *expression* **then** *statement* **else** *statement* | **while** *expression* **do** *statement* |  
**if** *expression* **then** *statement*

*variable*

> &#8594; **id** | **id [** *expression* **]**

*procedure_statement*

> &#8594; **call id** | **call id (** *expression_list* **)**

*expression_list*

> &#8594; *expression expression_list'*

*expression_list'*

> &#8594; **,** *expression expression_list'* | **&#949;**

*expression*

> &#8594; *simple_expression* | *simple_expression* **relop** *simple_expression*

*simple_expression*

> &#8594; *term simple_expression'* | *sign term simple_expression'*

*simple_expression'*

> &#8594; **addop** *term simple_expression'* | **&#949;**

*term*

> &#8594; *factor term'*

*term'*

> &#8594; **mulop** *factor term'* | **&#949;**

*factor*

> &#8594; **id** | **num** | **(** *expression* **)** | **not** *factor* | **id [** *expression* **]**

*sign*

> &#8594; **+** | **–**

#### Modified Grammar - Perform Left Factoring
The above grammar after performing left factoring and minor simplification is as follows (with labelled productions for use in the parse table):

*program*

> **P<sub>1</sub>** &#8594; **program id (** *identifier_list* **) ;** *program'*

*program'*

> **P<sub>2</sub>** &#8594;* compound_statement* **.**  
**P<sub>3</sub>** &#8594; *subprogram_declarations compound_statement* **.**  
**P<sub>4</sub>** &#8594; *declarations program"*

*program"*

> **P<sub>5</sub>** &#8594; *compound_statement*  **.**  
**P<sub>6</sub>** &#8594; *subprogram_declarations compound_statement* **.**

*identifier_list*

> **P<sub>7</sub>** &#8594; **id** *identifier_list'*

*identifier_list'*

> **P<sub>8</sub>** &#8594; **, id** *identifier_list'*  
**P<sub>9</sub>** &#8594; **&#949;**

*declarations*

> **P<sub>10</sub>** &#8594; **var id :** *type* **;** *declarations'*

*declarations'*

> **P<sub>11</sub>** &#8594; **var id :** *type* **;** *declarations'*  
**P<sub>12</sub>** &#8594; **&#949;**

*type*

> **P<sub>13</sub>** &#8594; *standard_type*  
**P<sub>14</sub>** &#8594; **array [ num .. num ] of** *standard_type*

*standard_type*

> **P<sub>15</sub>** &#8594; **integer**  
**P<sub>16</sub>** &#8594; **real**

*subprogram_declarations*

> **P<sub>17</sub>** &#8594; *subprogram_declaration* **;** *subprogram_declarations'*

*subprogram_declarations'*

> **P<sub>18</sub>** &#8594; *subprogram_declaration* **;** *subprogram_declarations'*
**P<sub>19</sub>** &#8594; **&#949;**

*subprogram_declaration*

> **P<sub>20</sub>** &#8594; *subprogram_head subprogram_declaration'*

*subprogram_declaration'*

> **P<sub>21</sub>** &#8594; *declarations subprogram_declaration"*  
**P<sub>22</sub>** &#8594; *compound_statement*  
**P<sub>23</sub>** &#8594; *subprogram_declarations compound_statement*

*subprogram_declaration"*

> **P<sub>24</sub>** &#8594; *compound_statement*  
**P<sub>25</sub>** &#8594; *subprogram_declarations compound_statement*

*subprogram_head*

> **P<sub>26</sub>** &#8594; **procedure id** *subprogram_head'*

*subprogram_head'*

> **P<sub>27</sub>** &#8594; *arguments* **;**  
**P<sub>28</sub>** &#8594; **;**

*arguments*

> **P<sub>29</sub>** &#8594; **(** *parameter_list* **)**

*parameter_list*

> **P<sub>30</sub>** &#8594; **id :** *type parameter_list'*

*parameter_list'*

> **P<sub>31</sub>** &#8594; **; id :** *type parameter_list'*  
**P<sub>32</sub>** &#8594; **&#949;**

*compound_statement*

> **P<sub>33</sub>** &#8594; **begin** *compound_statement'*

*compound_statement'*

> **P<sub>34</sub>** &#8594; *statement_list* **end**  
**P<sub>35</sub>** &#8594; **end**

*statement_list*

> **P<sub>36</sub>** &#8594; *statement statement_list'*

*statement_list'*

> **P<sub>37</sub>** &#8594; **;** *statement statement_list'*  
**P<sub>38</sub>** &#8594; **&#949;**

*statement*

> **P<sub>39</sub>** &#8594; *variable* **assignop** *expression*  
**P<sub>40</sub>** &#8594; *procedure_statement*  
**P<sub>41</sub>** &#8594; *compound_statement*  
**P<sub>42</sub>** &#8594; **if** *expression* **then** *statement statement'*  
**P<sub>43</sub>** &#8594; **while** *expression* **do** *statement*

*statement'*

> **P<sub>44</sub>** &#8594; **else** *statement*  
**P<sub>45</sub>** &#8594; **&#949;**

*variable*

> **P<sub>46</sub>** &#8594; **id** *variable'*

*variable'*

> **P<sub>47</sub>** &#8594; **[** *expression* **]**  
**P<sub>48</sub>** &#8594; **&#949;**

*procedure_statement*

> **P<sub>49</sub>** &#8594; **call id** *procedure_statement'*

*procedure_statement'*

> **P<sub>50</sub>** &#8594; **(** *expression_list* **)**  
**P<sub>51</sub>** &#8594; **&#949;**

*expression_list*

> **P<sub>52</sub>** &#8594; *expression expression_list'*

*expression_list'*

> **P<sub>53</sub>** &#8594; **,** *expression expression_list'*  
**P<sub>54</sub>** &#8594; **&#949;**

*expression*

> **P<sub>55</sub>** &#8594; *simple_expression expression'*

*expression'*

> **P<sub>56</sub>** &#8594; **relop** *simple_expression*  
**P<sub>57</sub>** &#8594; **&#949;**

*simple_expression*

> **P<sub>58</sub>** &#8594; *term simple_expression'*  
**P<sub>59</sub>** &#8594; *sign term simple_expression'*

*simple_expression'*

> **P<sub>60</sub>** &#8594; **addop** *term simple_expression'*  
**P<sub>61</sub>** &#8594; **&#949;**

*term*

> **P<sub>62</sub>** &#8594; *factor term'*

*term'*

> **P<sub>63</sub>** &#8594; **mulop** *factor term'*  
**P<sub>64</sub>** &#8594; **&#949;**

*factor*

> **P<sub>65</sub>** &#8594; **id** *factor'*  
**P<sub>66</sub>** &#8594; **num**  
**P<sub>67</sub>** &#8594; **(** *expression* **)**  
**P<sub>68</sub>** &#8594; **not** *factor*

*factor'*

> **P<sub>69</sub>** &#8594; **[** *expression* **]**  
**P<sub>70</sub>** &#8594; **&#949;**

*sign*

> **P<sub>71</sub>** &#8594; **+**  
**P<sub>72</sub>** &#8594; **–**

#### First Sets
The first sets based on the LL(1) grammar is as follows:

*program*: {**program**}

*program'*: {**begin**, **procedure**, **var**}

*program"*: {**begin**, **procedure**}

*identifier_list*: {**id**}

*identifier_list'*: { **,** , **&#949;**}

*declarations*: {**var**}

*declarations'*: {**var**, **&#949;**}

*type*: {**integer**, **real**, **array**}

*standard_type*: {**integer**, **real**}

*subprogram_declarations*: {**procedure**}

*subprogram_declarations'*: {**procedure**, **&#949;**}

*subprogram_declaration*: {**procedure**}

*subprogram_declaration'*: {**var**, **begin**, **procedure**}

*subprogram_declaration"*: {**begin**, **procedure**}

*subprogram_head*: {**procedure**}

*subprogram_head'*: { **(** , **;** }

*arguments*: { **(** }

*parameter_list*: {**id**}

*parameter_list'*: { **;** , **&#949;**}

*compound_statement*: {**begin**}

*compound_statement'*: {**id**, **call**, **begin**, **if**, **while**, **end**}

*statement_list*: {**id**, **call**, **begin**, **if**, **while**}

*statement_list'*: { **;** , **&#949;**}

*statement*: {**id**, **call**, **begin**, **if**, **while**}

*statement'*: {**else**, **&#949;**}

*variable*: {**id**}

*variable'*: { **[** , **&#949;**}

*procedure_statement*: {**call**}

*procedure_statement'*: { **(** , **&#949;**}

*expression_list*: {**id**, **num**, **(** , **not**, **+**, **–**}

*expression_list'*: { **,** , **&#949;**}

*expression*: {**id**, **num**, **(** , **not**, **+**, **–**}

*expression'*: {**relop**, **&#949;**}

*simple_expression*: {**id**, **num**, **(** , **not**, **+**, **–**}

*simple_expression'*: {**addop**, **&#949;**}

*term*: {**id**, **num**, **(** , **not**}

*term'*: {**mulop**, **&#949;**}

*factor*: {**id**, **num**, **(** , **not**}

*factor'*: { **[** , **&#949;**}

*sign*: {**+**, **–**}











#### Follow Sets
The follow sets based on the LL(1) grammar is as follows:

*program*: {**$**}

*program'*: {**$**}

*program"*: {**$**}

*identifier_list*: { **)** }

*identifier_list'*: { **)** }

*declarations*: {**begin**, **procedure**}

*declarations'*: {**begin**, **procedure**}

*type*: { **;** , **)** }

*standard_type*: { **;** , **)** }

*subprogram_declarations*: {**begin**}

*subprogram_declarations'*: {**begin**}

*subprogram_declaration*: { **;** }

*subprogram_declaration'*: { **;** }

*subprogram_declaration"*: { **;** }

*subprogram_head*: {**var**, **begin**, **procedure**}

*subprogram_head'*: {**var**, **begin**, **procedure**}

*arguments*: { **;** }

*parameter_list*: { **)** }

*parameter_list'*: { **)** }

*compound_statement*: { **.** , **else**, **;** , **end**}

*compound_statement'*: { **.** , **else**, **;** , **end**}

*statement_list*: {**end**}

*statement_list'*: {**end**}

*statement*: {**else**, **;** , **end**}

*statement'*: {**else**, **;** , **end**}

*variable*: {**assignop**}

*variable'*: {**assignop**}

*procedure_statement*: {**else**, **;** , **end**}

*procedure_statement'*: {**else**, **;** , **end**}

*expression_list*: { **)** }

*expression_list'*: { **)** }

*expression*: { **]** , **)** , **,** , **then**, **do**, **else**, **;** , **end**}

*expression'*: { **]** , **)** , **,** , **then**, **do**, **else**, **;** , **end**}

*simple_expression*: {**relop**, **]** , **)** , **,** , **then**, **do**, **else**, **;** , **end**}

*simple_expression'*: {**relop**, **]** , **)** , **,** , **then**, **do**, **else**, **;** , **end**}

*term*: {**addop**, **relop**, **]** , **)** , **,** , **then**, **do**, **else**, **;** , **end**}

*term'*: {**addop**, **relop**, **]** , **)** , **,** , **then**, **do**, **else**, **;** , **end**}

*factor*: {**mulop**, **addop**, **relop**, **]** , **)** , **,** , **then**, **do**, **else**, **;** , **end**}

*factor'*: {**mulop**, **addop**, **relop**, **]** , **)** , **,** , **then**, **do**, **else**, **;** , **end**}

*sign*: {**id**, **num**, **(** , **not**}


#### Parse Table
||program|id|var|array|num|integer|real|procedure|begin|end|assignop|if|then|else|while|do|call|relop|addop|mulop|not|+|-|(|)|;|[|]|,|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|**program**|1|||||||||||||||||||||||||||||
|**program'**|||4|||||3|2|||||||||||||||||||||
|**program"**||||||||6|5|||||||||||||||||||||
|**identifier_list**||7||||||||||||||||||||||||||||
|**identifier_list'**|||||||||||||||||||||||||9||||8|
|**declarations**|||10|||||||||||||||||||||||||||
|**declarations'**|||11|||||12|12|||||||||||||||||||||
|**type**||||14||13|13|||||||||||||||||||||||
|**standard_type**||||||15|16|||||||||||||||||||||||
|**subprogram_declarations**||||||||17||||||||||||||||||||||
|**subprogram_declarations'**||||||||18|19|||||||||||||||||||||
|**subprogram_declaration**||||||||20||||||||||||||||||||||
|**subprogram_declaration'**|||21|||||23|22|||||||||||||||||||||
|**subprogram_declaration"**||||||||25|24|||||||||||||||||||||
|**subprogram_head**||||||||26||||||||||||||||||||||
|**subprogram_head'**||||||||||||||||||||||||27||28||||
|**arguments**||||||||||||||||||||||||29||||||
|**parameter_list**||30||||||||||||||||||||||||||||
|**parameter_list'**|||||||||||||||||||||||||32|31||||
|**compound_statement**|||||||||33|||||||||||||||||||||
|**compound_statement'**||34|||||||34|35||34|||34||34|||||||||||||
|**statement_list**||36|||||||36|||36|||36||36|||||||||||||
|**statement_list'**||||||||||38||||||||||||||||37||||
|**statement**||39|||||||41|||42|||43||40|||||||||||||
|**statement'**||||||||||45||||44||||||||||||45||||
|**variable**||46||||||||||||||||||||||||||||
|**variable'**|||||||||||48||||||||||||||||47|||
|**procedure_statement**|||||||||||||||||49|||||||||||||
|**procedure_statement'**||||||||||51||||51||||||||||50||||||
|**expression_list**||52|||52||||||||||||||||52|52|52|52||||||
|**expression_list'**|||||||||||||||||||||||||54||||53|
|**expression**||55|||55||||||||||||||||55|55|55|55||||||
|**expression'**||||||||||57|||57|57||57||56|||||||57|||57|57|
|**simple_expression**||58|||58||||||||||||||||58|59|59|58||||||
|**simple_expression'**||||||||||61|||61|61||61||61|60||||||61|||61|61|
|**term**||62|||62||||||||||||||||62|||62||||||
|**term'**||||||||||64|||64|64||64||64|64|63|||||64|||64|64|
|**factor**||65|||66||||||||||||||||68|||67||||||
|**factor'**||||||||||70|||70|70||70||70|70|70|||||70||69|70|70|
|**sign**||||||||||||||||||||||71|72|||||||

## Implementation
My implementation of the recursive descent parser is written using the Python programming language. I began this project by slightly modifying my lexical analyzer to output the tokens and their data in a way that would be more readable by the parser. The syntax analysis process begins immediately once the lexical analysis process is complete. The token file generated by the lexical analyzer is passed to the parser. Using the LL(1) grammar from above, the parser takes tokens from the token file and matches their order to the grammar until the end of the program is reached. The parse is complete at this point. While the parser is running, if there is an unexpected token at any time, the parser will run its synch routine, in which the parser will loop through tokens until a valid one is reached, then continue parsing until there are no more tokens. During the synch process, it is possible that all the tokens except for $ could be removed from the stack, so there will always be a correct token for the synch process the fall back on.

## Discussion and Conclusions
This project was fairly straightforward to implement into a program once I massaged the grammar. The massaging process into an LL(1) grammar required my undivided attention to ensure I was doing it correctly. None of the individual processes were too difficult, but it was extremely time consuming and meticulous work. Finding the first and follow sets and building the parse table were straightforward tasks. Once those were built, it was easy to write the recursive descent parse program itself. Overall, this project seemed quite a bit easier than the first project, but required more time to ensure correctness.

## References
Aho, Alfred V., Ravi Sethi, and Jeffrey D. Ullman. *Compilers: Principles, Techniques, and Tools*. 1st ed. Bell Laboratories, 1986. Print.

## Appendix - Sample Inputs and Outputs
### No errors (happy path)
#### Inputs
* [src\_program](SampleInputs/src_program_no_errors)

#### Outputs
* [listing\_file](SampleOutputs/listing_file_without_errors)

### With errors (syntax errors)
#### Inputs
* [src\_program](SampleInputs/src_program_with_errors)

#### Outputs
* [listing\_file](SampleOutputs/listing_file_with_errors)
